const cloudinary = require('cloudinary').v2;
const fs = require('fs');
const path = require('path');
require('dotenv').config();

// Config
cloudinary.config({
    cloud_name: process.env.VITE_CLOUDINARY_CLOUD_NAME,
    api_key: process.env.VITE_CLOUDINARY_API_KEY,
    api_secret: process.env.VITE_CLOUDINARY_API_SECRET
});

const IMAGES_DIR = path.join(__dirname, '../src/assets/images');
const OUTPUT_FILE = path.join(__dirname, '../src/data/imageUrls.js');

async function migrate() {
    console.log('Starting migration...');
    const files = fs.readdirSync(IMAGES_DIR);

    // Load existing mapping if exists
    let mapping = {};
    if (fs.existsSync(OUTPUT_FILE)) {
        try {
            const existingContent = fs.readFileSync(OUTPUT_FILE, 'utf8');
            // Extract JSON from the file using regex since it's an ES6 export
            const match = existingContent.match(/export const IMAGES = ({[\s\S]*?});/);
            if (match && match[1]) {
                mapping = JSON.parse(match[1]);
                console.log(`Loaded ${Object.keys(mapping).length} existing images.`);
            }
        } catch (e) {
            console.warn("Could not parse existing imageUrls.js, starting fresh.");
        }
    }

    for (const file of files) {
        if (['.jpg', '.jpeg', '.png', '.svg', '.webp'].includes(path.extname(file).toLowerCase())) {
            // Skip if already exists and we want to be efficient, but user said migrate all, so maybe upload again? 
            // Let's assume we upload if it's not in mapping OR if we want to ensure latest. 
            // For safety/speed, let's upload.
            console.log(`Uploading ${file}...`);
            try {
                const result = await cloudinary.uploader.upload(path.join(IMAGES_DIR, file), {
                    folder: 'norway_project',
                    use_filename: true,
                    unique_filename: false
                });
                mapping[file] = result.secure_url;
                console.log(`✔ Uploaded: ${file}`);
            } catch (error) {
                console.error(`❌ Failed: ${file}`, error.message);
            }
        }
    }

    // Sort keys for tidiness
    const sortedMapping = Object.keys(mapping).sort().reduce((acc, key) => {
        acc[key] = mapping[key];
        return acc;
    }, {});

    const content = `// Auto-generated by scripts/migrateImages.js
export const IMAGES = ${JSON.stringify(sortedMapping, null, 4)};
`;

    fs.writeFileSync(OUTPUT_FILE, content);
    console.log(`Migration complete! URLs saved to ${OUTPUT_FILE}`);
}

migrate();
